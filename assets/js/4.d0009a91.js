(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{277:function(t,s,a){t.exports=a.p+"assets/img/io_1.0590a71a.jpeg"},278:function(t,s,a){t.exports=a.p+"assets/img/io_2.848fa31e.png"},279:function(t,s,a){t.exports=a.p+"assets/img/io_3.90615185.png"},280:function(t,s,a){t.exports=a.p+"assets/img/io_4.0d819055.png"},281:function(t,s,a){t.exports=a.p+"assets/img/io_5.7f7ab340.png"},282:function(t,s,a){t.exports=a.p+"assets/img/bio.84d4f512.gif"},283:function(t,s,a){t.exports=a.p+"assets/img/nio.e87015b0.gif"},284:function(t,s,a){t.exports=a.p+"assets/img/mio.78bda738.gif"},285:function(t,s,a){t.exports=a.p+"assets/img/sio.bd1a1554.gif"},286:function(t,s,a){t.exports=a.p+"assets/img/aio.0d1a84d2.gif"},364:function(t,s,a){"use strict";a.r(s);var _=a(10),v=Object(_.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"io读写原理与io模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#io读写原理与io模型"}},[t._v("#")]),t._v(" IO读写原理与IO模型")]),t._v(" "),s("h2",{attrs:{id:"概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),s("blockquote",[s("p",[t._v("I/O，即输入/输出(Input/Output)。用户程序进行IO操作并不是直接操作硬件设备进行读写，而是通过调用操作系统提供的函数，真正的IO操作是由操作系统内核来完成的。在进行IO操作时CPU会从用户态切换为内核态，而操作结束后又需要从内核态切换为用户态，频繁的状态切换会使 CPU将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，从而影响程序运行效率。此外，除了系统调用产生的CPU上下文切换，线程上下文切换也面临着该问题。")])]),t._v(" "),s("h2",{attrs:{id:"内核空间与用户空间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内核空间与用户空间"}},[t._v("#")]),t._v(" 内核空间与用户空间")]),t._v(" "),s("p",[t._v("为了保护操作系统安全，操作系统按照特权等级将将虚拟空间划分为两个部分，内核空间与用户空间。内核空间（Ring 0）是操作系统内核访问的区域，具有最高权限，可以直接访问所有资源。用户空间（Ring 3）是普通应用程序可访问的内存区域，只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。只能访问用户空间也就是运行在Ring 3上的程序我们称为用户程序，而运行在Ring 0上的程序我们称为内核程序。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(277),alt:"cea11f03bddf5fa1ae64f5717cbc96b9"}})]),t._v(" "),s("h2",{attrs:{id:"内核态与用户态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内核态与用户态"}},[t._v("#")]),t._v(" 内核态与用户态")]),t._v(" "),s("p",[t._v("用户程序不能访问内核空间，如果想要调用内核程序进行IO操作，必须从用户态切换为内核态，等到内核处理完之后再切换为用户态。")]),t._v(" "),s("ul",[s("li",[t._v("**内核态：**处理器处于特权级最高的（Ring 0）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。")]),t._v(" "),s("li",[t._v("**用户态：**此时处理器在特权级最低的（Ring 3）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。")])]),t._v(" "),s("p",[t._v("用户程序进行IO操作时需要进行两次状态切换：用户态->内核态->用户态，具体流程如下：")]),t._v(" "),s("ol",[s("li",[t._v("用户态程序将一些数据值放在寄存器中，或者使用参数创建一个堆栈(stack frame)，以此表明需要操作系统提供的服务")]),t._v(" "),s("li",[t._v("用户态程序执行陷阱指令")]),t._v(" "),s("li",[t._v("CPU切换到内核态，并跳到位于内存指定位置的指令，这些指令是操作系统的一部分, 他们具有内存保护，不可被用户态程序访问")]),t._v(" "),s("li",[t._v("这些指令称之为陷阱(trap)或者系统调用处理器(system call handler)，他们会读取程序放入内存的数据参数，并执行程序请求的服务")]),t._v(" "),s("li",[t._v("系统调用完成后，操作系统会重置CPU为用户态并返回系统调用的结果")])]),t._v(" "),s("h2",{attrs:{id:"内核缓冲区与用户缓冲区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内核缓冲区与用户缓冲区"}},[t._v("#")]),t._v(" 内核缓冲区与用户缓冲区")]),t._v(" "),s("p",[t._v("用户程序每进行一次系统调用都会进行两次状态切换，频繁的状态切换会影响程序运行效率，缓冲区的作用就是为了加少系统调用。缓冲区分为两种：内核缓冲区与用户缓冲区：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("**内核缓冲区：**用户进程要从磁盘读取数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据拷贝到进程缓冲区中，如果内核缓冲区中没有数据时，则先将数据从磁盘拷贝到内核缓冲区，然后再将内核缓冲区的数据拷贝到进程缓冲区")])]),t._v(" "),s("li",[s("p",[t._v("**用户缓冲区：**为了减少系统调用次数，从而降低操作系统在用户态与核心态切换所耗费的时间，用户程序从磁盘拷贝数据的时候可以先申请一块内存空间，每次进行系统调用读取数据时将数据写入该内存空间，之后程序从该内存空间读取数据进行处理，等到该空间数据处理完再发起系统调用")])])]),t._v(" "),s("h2",{attrs:{id:"io读写流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#io读写流程"}},[t._v("#")]),t._v(" IO读写流程")]),t._v(" "),s("p",[t._v("用户程序进行IO读写操作会发起系统调用，操作系统内核将磁盘数据读取到内核缓冲区，然后从内核缓冲区拷贝到用户缓冲区，流程如下：")]),t._v(" "),s("p",[s("img",{attrs:{src:a(278),alt:"io读写流程"}})]),t._v(" "),s("h2",{attrs:{id:"零拷贝"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#零拷贝"}},[t._v("#")]),t._v(" 零拷贝")]),t._v(" "),s("blockquote",[s("p",[t._v("是指"),s("a",{attrs:{href:"https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338",target:"_blank",rel:"noopener noreferrer"}},[t._v("计算机"),s("OutboundLink")],1),t._v("执行操作时，"),s("a",{attrs:{href:"https://baike.baidu.com/item/CPU",target:"_blank",rel:"noopener noreferrer"}},[t._v("CPU"),s("OutboundLink")],1),t._v("不需要先将数据从某处"),s("a",{attrs:{href:"https://baike.baidu.com/item/%E5%86%85%E5%AD%98",target:"_blank",rel:"noopener noreferrer"}},[t._v("内存"),s("OutboundLink")],1),t._v("复制到另一个特定区域。这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。若采用零拷贝技术，则能极大地增强了特定应用程序的性能，并更有效地利用系统资源。通过使CPU得以完成其他而非将机器中的数据复制到另一处的任务，性能也得到了增强。另外，零拷贝操作减少了在用户空间与内核空间之间切换模式的次数。")])]),t._v(" "),s("p",[t._v("举例来说，如果要读取一个文件并通过网络发送它，传统方式下每个读/写周期都需要复制两次数据和切换两次上下文，而数据的复制都需要依靠CPU。通过零复制技术完成相同的操作，上下文切换减少到两次，并且不需要CPU复制数据。")]),t._v(" "),s("p",[s("strong",[t._v("不使用零拷贝")])]),t._v(" "),s("p",[t._v("不适用零拷贝需要经历四次数据拷贝+三次状态切换")]),t._v(" "),s("p",[s("img",{attrs:{src:a(279),alt:"零拷贝(1)"}})]),t._v(" "),s("p",[s("strong",[t._v("mmap + write")])]),t._v(" "),s("p",[t._v("mmap + write方式减少了一次CPU拷贝")]),t._v(" "),s("p",[s("img",{attrs:{src:a(280),alt:"零拷贝的副本(1)"}})]),t._v(" "),s("p",[s("strong",[t._v("sendfile")])]),t._v(" "),s("p",[t._v("sendfile方式不涉及CPU拷贝")]),t._v(" "),s("p",[s("img",{attrs:{src:a(281),alt:"零拷贝的副本2"}})]),t._v(" "),s("h2",{attrs:{id:"io模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#io模型"}},[t._v("#")]),t._v(" IO模型")]),t._v(" "),s("p",[t._v("在讲解IO模型前，先了解下几个概念：阻塞与非阻塞、同步与异步：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("**阻塞与非阻塞：**用户进程发起系统调用，此时如果内核缓冲区中没有数据，则需要将数据从磁盘拷贝到内核缓冲区，这个过程称之为数据准备，阻塞与非阻塞的区别就是：用户进程是否等待数据数据准备完成。阻塞：用户进程在这个过程中一直阻塞，直至数据准备完成，并且数据从内核缓冲区拷贝到用户缓冲区成功；非阻塞：用户进程发起系统调用，不等数据准备完成，内核立即返回一个标志信息。")])]),t._v(" "),s("li",[s("p",[t._v("**同步与异步：**同步与异步的区别是：用户进程发起系统调用，需不需要等待成功结果。同步：需要等待结果；异步：不需要等待结果，由内核处理完成后通知结果。")])])]),t._v(" "),s("p",[s("strong",[t._v("阻塞IO")])]),t._v(" "),s("p",[t._v("用户进程发起系统调用，如果数据还未准备完成，用户进程一直等待，直到数据准备完成，从内核缓冲区拷贝到用户缓冲区才返回成功提示，此次IO操作，称之为阻塞IO。缺点：如果数据没有准备好，则用户进程一直处于阻塞状态，如果想要同时处理很多请求，则需要为每个请求分配线程进行处理，系统开销较大。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(282),alt:"bio"}})]),t._v(" "),s("p",[s("strong",[t._v("非阻塞IO")])]),t._v(" "),s("p",[t._v("用户进程发起系统调用，如果数据还未准备好，立刻返回状态标识，用户进程后续可以通过轮询的方式查看结果。缺点：虽然用户进程不阻塞了，但需要频繁的轮询获取结果，这样会导致频繁的系统调用，消耗大量的CPU资源。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(283),alt:"bio"}})]),t._v(" "),s("p",[s("strong",[t._v("IO多路复用")])]),t._v(" "),s("p",[t._v("将IO事件注册到IO多路复用器（select/poll/epoll）上，select调用进程将一直阻塞直至注册在其上的任意一个IO时间数据准备完成时，才会返回。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(284),alt:"mio"}})]),t._v(" "),s("p",[s("strong",[t._v("信号驱动IO")])]),t._v(" "),s("p",[t._v("用户进程发起系统调用，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(285),alt:"sio"}})]),t._v(" "),s("p",[s("strong",[t._v("异步IO")])]),t._v(" "),s("p",[t._v("用户进程发起系统调用后直接返回，等到处理完成，主动通知进程结果。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(286),alt:"aio"}})]),t._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("p",[t._v("对本文做个回顾：")]),t._v(" "),s("p",[t._v("用户进程运行在用户空间，只能访问受限资源，如果需要访问磁盘等硬件设备需要发起系统调用，从用户态切换为用户态；")]),t._v(" "),s("p",[t._v("为了减少频繁的系统调用，降低CPU消耗，讲解了内核缓冲区与用户缓冲区的作用；")]),t._v(" "),s("p",[t._v("IO读写流程，需要经历两次状态切换与两次数据拷贝；")]),t._v(" "),s("p",[t._v("零拷贝原理；")]),t._v(" "),s("p",[t._v("阻塞与非阻塞、同步与异步概念，四种同步IO模型，一种异步IO模型。")])])}),[],!1,null,null,null);s.default=v.exports}}]);